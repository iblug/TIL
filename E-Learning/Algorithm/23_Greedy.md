# 그리디(Greedy) 알고리즘
* **탐욕법**
* **현재 상황에서 지금 당장 좋은 것만 고르는 방법**
* 일반적인 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구
* 그리디 해법은 그 정당성 분석이 중요
  * 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토
* 일반적인 상황에서 그리디 알고리즘은 최적의 해를 보장할 수 없을 때가 많음
  * 하지만 코딩 테스트에서의 대부분의 그리디 문제는 **탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론**할 수 있어야 풀리도록 출제

## <문제> 거스름 돈
* 문제 설명
  * ...
- 문제 해결 아이디어
  * 최적의 해를 빠르게 구하기 위해서는 **가장 큰 화폐 단위부터** 돈을 거슬러 주면 됨
* N원을 거슬러 줘야 할 때, 가장 먼저 500원으로 거슬러 줄 수 있을 만큼 거슬러 줌
  * 이후에 100원, 50원, 10원짜리 동전을 차례대로 거슬러 줄 수 있을 만큼 거슬러 주면 됨
- **정당성 분석**
  * 가장 큰 화폐 단위부터 돈을 거슬러 주는 것이 최적의 해를 보장하는 이유는 무엇일까?
    * 가지고 있는 동전 중에서 **큰 단위가 항상 작은 단위의 <u>배수</u>이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문**
  * 만약에 800원을 거슬러 주어야 하는데 화폐 단위가 500원, 400원, 100원이라면?
    * 그 리 디 : 4개(500, 100, 100, 100)
    * 최적의 해: 2개(400, 400)
      * *그리디로 해결할 수 없음*
  * 대부분의 그리디 알고리즘 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 답을 도출할 수 있음
* 예시 답
```py
# 3-1 90
n = 1260
count = 0

# 큰 단위의 화폐부터 차례대로 확인
coin_types = [500, 100, 50, 10]

for coin in coin_types:
  count += n // coin # 해당 화폐로 거슬러 줄 수 있는 동전의 개수 세기
  n %= coin

print(count)
```
- 시간 복잡도 분석
  * 화폐의 종류가 K라고 할 때, 소스코드의 시간 복잡도는 **O(K)**
  * 이 알고리즘의 시간 복잡도는 거슬러줘야 하는 금액과는 무관하며, 동전의 총 종류에만 영향을 받음

## <문제> 1이 될 때까지
* 문제 설명
  * ...
- 문제 해결 아이디어
  * 주어진 N에 대하여 **최대한 많이 나누기**를 수행하면 됨
  * N의 값을 줄일 때 **2 이상의 수로 나누는 작업**이 **1을 빼는 작업보다** 수를 훨씬 많이 줄일 수 있음
* **정당성 분석**
  * **가능하면 최대한 많이 나누는 작업**이 최적의 해를 항상 보장할 수 있을까?
  * N이 아무리 큰 수여도, K로 계속 나눈다면 기하급수적으로 빠르게 줄일 수 있음
  * 다시 말해 K가 2 이상이기만 하면, K로 나누는 것이 1을 빼는 것보다 항상 빠르게 N을 줄일 수 있음
    * 또한 N은 항상 1에 도달하게 됨(최적의 해 성립)
- 예시 답
```py
# 3-5-1 101
# N, K를 공백을 기준으로 구분하여 입력 받기
n, k = map(int, input().split())
result = 0

# N이 K 이상이라면 K로 계속 나누기
while True:
  # N이 K로 나누어 떨어지는 수가 될 때까지 빼기
  target = (n // k) * k
  result += (n - target)
  n = target
  # N이 K보다 작을 때 (더 이상 나눌 수 없을 때) 반복문 탈출
  if n < k:
    break
  # K로 나누기
  result += 1
  n //= k
# 마지막으로 남은 수에 대하여 1씩 빼기
result += (n - 1)
print(result)
```

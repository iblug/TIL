# 깊이우선탐색(DFS)
## 목차
1. 그래프 탐색 알고리즘
2. 깊이우선탐색(DFS)
3. DFS의 동작 과정
4. DFS의 구현 방식
5. DFS 문제 풀이
6. 이차원 격자에서의 DFS

# 1. 그래프 탐색 알고리즘
* 시작 정점에서 **간선을 타고 이동할 수 있는 모든 정점을 찾는** 알고리즘
* **깊이우선탐색(Depth-First Search, DFS)**
  * 그래프의 깊이를 우선으로 탐색하기 위해 **스택**의 개념을 활용
* **너비우선탐색(Breadth-First Search, BFS)**
  * 그래프의 너비를 우선으로 탐색하기 위해 **큐**의 개념을 활용

# 2. 깊이우선탐색(DFS)
* 시작 정점으로부터 **갈 수 있는 하위 정점까지 가장 깊게 탐색**하고, 더 이상 갈 곳이 없다면 마지막 갈림길로 돌아와서 다른 정점을 탐색하며 결국 모든 정점을 방문하는 순회 방법
* **모든 정점을 방문**할 때 유리
  * **경우의 수, 순열과 조합** 문제에서 많이 사용
* 너비우선탐색(BFS)에 비해 코드 구현이 간단
  * *모든 정점을 방문할 필요가 없거나 최단 거리를 구하는 경우에는 너비우선탐색(BFS)이 유리*

# 3. DFS의 동작 과정
* **인접 행렬** 혹은 **인접 리스트** 그래프 필요
* **각 정점을 방문했는지 여부를 판별**할 방문 체크 리스트
* **DFS의 사이클**
    1. 정점 방문처리 및 스택에 값 삽입
    2. 스택 최상단 값 꺼내고 인접한 정점 확인
    3. 방문하지 않은 인접 정점이면 1번으로 돌아가 반복

# 4. DFS의 구현 방식
* 반복문을 이용한 DFS
  * DFS는 직전에 방문한 정점으로 차례로 돌아가야 하므로, 후입선출(LIFO)구조의 **스택**을 사용
```py
def dfs(start):
  stack = [start] # 돌아갈 곳을 기록
  visited[start] = True # 시작 정점 방문 처리

  while stack: # 스택이 빌 때까지(돌아갈 곳이 없을 때 까지) 반복
    cur = stack.pop() # 현재 방문 정점(후입선출)

    for adj in graph[cur]: # 인접한 모든 정점에 대해
      if not visited[adj]: # 아직 방문하지 않았다면
        visited[adj] = True # 방문 처리
        stack.append(adj) # 스택에 넣기

visited = [False] * n # 방문 처리 리스트 만들기
graph = [
  [1, 2], 
  [0, 3, 4], 
  [0, 4, 5], 
  [1], 
  [1, 2, 6], 
  [2], 
  [4]
]

dfs(0) # 0번 정점에서 시작
```

# 5. DFS 문제 풀이
* [BOJ 2606 바이러스](https://www.acmicpc.net/problem/2606)

# 6. 이차원 격자에서의 DFS
